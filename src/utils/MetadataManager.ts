import { ViwoodsNoteMetadata } from "../models/Settings";
import { StreamLogger } from "./StreamLogger";

/**
 * Manages Viwoods note metadata in a markdown file with YAML frontmatter
 * Stored in the Paper resources folder as viwoodsNoteMetadata.md
 */
export class MetadataManager {
	private metadata: Record<string, ViwoodsNoteMetadata> = {};
	private metadataFilePath: string;
	private loadDataFn: () => Promise<Record<string, ViwoodsNoteMetadata> | null>;
	private saveDataFn: (data: Record<string, ViwoodsNoteMetadata>) => Promise<void>;

	constructor(
		metadataFilePath: string,
		loadDataFn: () => Promise<Record<string, ViwoodsNoteMetadata> | null>,
		saveDataFn: (data: Record<string, ViwoodsNoteMetadata>) => Promise<void>
	) {
		this.metadataFilePath = metadataFilePath;
		this.loadDataFn = loadDataFn;
		this.saveDataFn = saveDataFn;
	}

	/**
	 * Load metadata from markdown file with YAML frontmatter
	 */
	async load(): Promise<void> {
		try {
			const data = await this.loadDataFn();
			this.metadata = data || {};
			StreamLogger.log("[MetadataManager] Loaded metadata", {
				path: this.metadataFilePath,
				count: Object.keys(this.metadata).length,
				entries: Object.entries(this.metadata).map(([key, val]) => ({
					key,
					pageCount: val.pages.length
				}))
			});
		} catch (error) {
			StreamLogger.warn("[MetadataManager] Failed to load metadata, using empty", error);
			this.metadata = {};
		}
	}

	/**
	 * Save metadata to markdown file with YAML frontmatter
	 */
	async save(): Promise<void> {
		try {
			// Log metadata details before saving
			StreamLogger.log("[MetadataManager] Saving metadata", {
				path: this.metadataFilePath,
				count: Object.keys(this.metadata).length,
				entries: Object.entries(this.metadata).map(([key, val]) => ({
					key,
					lastModified: val.lastModified,
					pageCount: val.pages.length
				}))
			});

			await this.saveDataFn(this.metadata);
			StreamLogger.log("[MetadataManager] Saved metadata successfully");
		} catch (error) {
			StreamLogger.error("[MetadataManager] Failed to save metadata", error);
			throw error;
		}
	}

	/**
	 * Convert metadata to markdown content with YAML frontmatter
	 */
	public static toMarkdown(metadata: Record<string, ViwoodsNoteMetadata>): string {
		// Create YAML frontmatter with metadata
		const yaml = MetadataManager.toYAML(metadata);

		// Create markdown content
		return `---
${yaml}
---

# Viwoods Paper Note Metadata

This file tracks metadata for Viwoods Paper notes to support intelligent merging.

**DO NOT EDIT THIS FILE MANUALLY** - It is managed automatically by the Dropbox Fetcher plugin.

## Metadata Structure

Each note entry contains:
- \`fileId\`: Dropbox file ID
- \`lastModified\`: Last modified timestamp
- \`notePath\`: Path to the markdown note in vault
- \`pages\`: Array of page metadata with page number and image path
`;
	}

	/**
	 * Convert metadata object to YAML string
	 */
	private static toYAML(metadata: Record<string, ViwoodsNoteMetadata>): string {
		const lines: string[] = [];
		lines.push('notes:');

		for (const [key, value] of Object.entries(metadata)) {
			// Escape key if needed (YAML safe string)
			const safeKey = key.includes(':') || key.includes('"') ? `"${key.replace(/"/g, '\\"')}"` : key;
			lines.push(`  ${safeKey}:`);
			lines.push(`    fileId: "${value.fileId}"`);
			lines.push(`    lastModified: ${value.lastModified}`);
			lines.push(`    notePath: "${value.notePath}"`);
			lines.push(`    pages:`);

			for (const page of value.pages) {
				lines.push(`      - page: ${page.page}`);
				lines.push(`        image: "${page.image}"`);
			}
		}

		return lines.join('\n');
	}

	/**
	 * Parse markdown content with YAML frontmatter to extract metadata
	 */
	public static fromMarkdown(content: string): Record<string, ViwoodsNoteMetadata> | null {
		// Extract YAML frontmatter
		const match = content.match(/^---\n([\s\S]*?)\n---/);
		if (!match) {
			return null;
		}

		const yamlContent = match[1];
		return MetadataManager.fromYAML(yamlContent);
	}

	/**
	 * Parse YAML string to metadata object
	 */
	private static fromYAML(yaml: string): Record<string, ViwoodsNoteMetadata> | null {
		try {
			// Simple YAML parser for our specific structure
			const metadata: Record<string, ViwoodsNoteMetadata> = {};
			const lines = yaml.split('\n');

			let currentKey: string | null = null;
			let currentMetadata: Partial<ViwoodsNoteMetadata> | null = null;
			let inPages = false;
			let currentPage: { page?: number; image?: string } | null = null;

			for (let i = 0; i < lines.length; i++) {
				const line = lines[i];

				// Skip empty lines and comments
				if (!line.trim() || line.trim().startsWith('#')) {
					continue;
				}

				// Match note key (EXACTLY 2 spaces indent, not followed by more spaces)
				const noteMatch = line.match(/^ {2}([^:]+):\s*$/);
				if (noteMatch && !line.startsWith('   ')) {
					// Save previous note if exists
					if (currentKey && currentMetadata) {
						StreamLogger.log(`[MetadataManager.fromYAML] Saving note: ${currentKey}`, {
							hasFileId: !!currentMetadata.fileId,
							hasLastModified: currentMetadata.lastModified !== undefined,
							hasNotePath: !!currentMetadata.notePath,
							hasPages: !!currentMetadata.pages,
							pagesLength: currentMetadata.pages?.length || 0
						});
					}
					if (currentKey && currentMetadata && currentMetadata.fileId && currentMetadata.lastModified !== undefined && currentMetadata.notePath && currentMetadata.pages) {
						metadata[currentKey] = currentMetadata as ViwoodsNoteMetadata;
						StreamLogger.log(`[MetadataManager.fromYAML] Successfully saved note: ${currentKey}`);
					} else if (currentKey) {
						StreamLogger.warn(`[MetadataManager.fromYAML] Skipped note ${currentKey} - missing required fields`);
					}

					// Start new note
					currentKey = noteMatch[1].replace(/^"|"$/g, ''); // Remove quotes if present
					currentMetadata = { pages: [] };
					inPages = false;
					continue;
				}

				// Match fileId (4 spaces indent)
				const fileIdMatch = line.match(/^ {4}fileId: "([^"]+)"/);
				if (fileIdMatch && currentMetadata) {
					currentMetadata.fileId = fileIdMatch[1];
					continue;
				}

				// Match lastModified (4 spaces indent)
				const lastModifiedMatch = line.match(/^ {4}lastModified: (\d+)/);
				if (lastModifiedMatch && currentMetadata) {
					currentMetadata.lastModified = parseInt(lastModifiedMatch[1], 10);
					continue;
				}

				// Match notePath (4 spaces indent)
				const notePathMatch = line.match(/^ {4}notePath: "([^"]+)"/);
				if (notePathMatch && currentMetadata) {
					currentMetadata.notePath = notePathMatch[1];
					continue;
				}

				// Match pages array start (4 spaces indent)
				if (line.match(/^ {4}pages:\s*$/) && currentMetadata) {
					inPages = true;
					continue;
				}

				// Match page array item (6 spaces indent with -)
				if (line.match(/^ {6}- page: (\d+)/) && inPages && currentMetadata) {
					const pageMatch = line.match(/^ {6}- page: (\d+)/);
					if (pageMatch) {
						currentPage = { page: parseInt(pageMatch[1], 10) };
					}
					continue;
				}

				// Match image path (8 spaces indent)
				const imageMatch = line.match(/^ {8}image: "([^"]+)"/);
				if (imageMatch && currentPage && currentMetadata && currentMetadata.pages) {
					currentPage.image = imageMatch[1];
					if (currentPage.page !== undefined && currentPage.image) {
						currentMetadata.pages.push({
							page: currentPage.page,
							image: currentPage.image,
						});
					}
					currentPage = null;
					continue;
				}
			}

			// Save last note if exists
			if (currentKey && currentMetadata && currentMetadata.fileId && currentMetadata.lastModified !== undefined && currentMetadata.notePath && currentMetadata.pages) {
				metadata[currentKey] = currentMetadata as ViwoodsNoteMetadata;
			}

			return metadata;
		} catch (error) {
			StreamLogger.error("[MetadataManager] Failed to parse YAML", error);
			return null;
		}
	}

	/**
	 * Get metadata for a specific note
	 */
	get(key: string): ViwoodsNoteMetadata | undefined {
		return this.metadata[key];
	}

	/**
	 * Set metadata for a specific note
	 */
	set(key: string, value: ViwoodsNoteMetadata): void {
		this.metadata[key] = value;
	}

	/**
	 * Delete metadata for a specific note
	 */
	delete(key: string): void {
		delete this.metadata[key];
	}

	/**
	 * Get all metadata
	 */
	getAll(): Record<string, ViwoodsNoteMetadata> {
		return { ...this.metadata };
	}

	/**
	 * Clear all metadata
	 */
	clear(): void {
		this.metadata = {};
	}

	/**
	 * Find metadata by content hash (for detecting renamed notes)
	 * Returns the first matching entry where contentHash matches but fileId differs
	 *
	 * @param contentHash Content hash to search for
	 * @param excludeFileId File ID to exclude from search (the new file's ID)
	 * @returns Matching metadata entry or undefined
	 */
	findByContentHash(contentHash: string, excludeFileId: string): { key: string; metadata: ViwoodsNoteMetadata } | undefined {
		for (const [key, metadata] of Object.entries(this.metadata)) {
			if (metadata.contentHash === contentHash && metadata.fileId !== excludeFileId) {
				StreamLogger.log("[MetadataManager] Found note with matching content hash", {
					key,
					oldFileId: metadata.fileId,
					newFileId: excludeFileId,
					contentHash,
				});
				return { key, metadata };
			}
		}
		return undefined;
	}

	/**
	 * Check if a fileId already exists in metadata
	 *
	 * @param fileId Dropbox file ID to check
	 * @returns True if fileId exists
	 */
	hasFileId(fileId: string): boolean {
		return Object.values(this.metadata).some(m => m.fileId === fileId);
	}
}
